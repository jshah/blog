<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      jshah &middot; Personal Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          jshah
        </a>
      </h1>
      <p class="lead">A personal blog</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archive</a>
          
        
      
        
      
        
          
        
      
    </nav>

    <p>&copy; 2020. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/rails/ruby/connection_pool/threads/2020/05/26/thread-safe-connection-pool-in-ruby/">
        Thread Safe Connection Pool in Ruby
      </a>
    </h1>

    <span class="post-date">26 May 2020</span>

    <p>To demonstrate a thread safe implementation of a connection pool, we will use a class instance variable, a Mutex, and the <a href="https://github.com/mperham/connection_pool">connection_pool</a> gem.</p>

<h3 id="class-instance-variables">Class Instance Variables</h3>

<p>Class instance variables work like regular class variables except for two main differences.</p>

<ol>
  <li>Class instance variables are available only to class methods and not to instance methods.</li>
  <li>Class instance variables are not shared with sub-classes. They belong exclusively to the class itself.</li>
</ol>

<p>We will use class instance variables (mainly for reason 1) to share a connection pool which all threads will be able to access. Here is a quick example of what class instance variables can do for us.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Example</span>
  <span class="vi">@my_value</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="c1"># class methods</span>

    <span class="k">def</span> <span class="nf">my_value</span>
      <span class="vi">@my_value</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">my_value</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="vi">@my_value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># instance methods</span>

  <span class="k">def</span> <span class="nf">my_value</span>
    <span class="vi">@my_value</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">my_value</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="vi">@my_value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># class method</span>
<span class="nb">puts</span> <span class="no">Example</span><span class="p">.</span><span class="nf">my_value</span> <span class="c1"># my_value = 1</span>
<span class="no">Example</span><span class="p">.</span><span class="nf">my_value</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">puts</span> <span class="no">Example</span><span class="p">.</span><span class="nf">my_value</span> <span class="c1"># my_value = 2</span>

<span class="c1"># instance method</span>
<span class="n">a</span> <span class="o">=</span> <span class="no">Example</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">puts</span> <span class="n">a</span><span class="p">.</span><span class="nf">my_value</span> <span class="c1"># my_value is not initialized at the instance level</span>
<span class="n">a</span><span class="p">.</span><span class="nf">my_value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">puts</span> <span class="n">a</span><span class="p">.</span><span class="nf">my_value</span> <span class="c1"># my_value = 3</span>

<span class="c1"># class method</span>
<span class="nb">puts</span> <span class="no">Example</span><span class="p">.</span><span class="nf">my_value</span> <span class="c1"># my_value is still 2 at the class level</span>
</code></pre></div></div>

<p>When <code class="highlighter-rouge">my_value</code> was accessed by class methods, its value was only accessed and updated at the class level. When accessed as an instance method, it was accessed and updated in a separate memory space at the instance level.</p>

<p>If you want to learn more about class instance variables, take a look at this <a href="https://www.codegram.com/blog/understanding-class-instance-variables-in-ruby/">article</a> and this <a href="https://stackoverflow.com/questions/15773552/ruby-class-instance-variable-vs-class-variable">post</a>.</p>

<p>Now that we have a way to access the <em>same</em> connection pool across threads, we need to actually create the pool so threads can use it.</p>

<h3 id="connection-pool">Connection Pool</h3>

<p>The <a href="https://github.com/mperham/connection_pool">connection_pool</a> gem will allow us to create a pool of connections which we can use to grab a connection and return it after we’re done using it. This allows us to specify a static number of connections and forces our threads to share those connections.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ConnectionManager</span>
  <span class="vi">@pool</span> <span class="o">=</span> <span class="kp">nil</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">connection_pool</span>
      <span class="vi">@pool</span> <span class="o">||</span> <span class="n">create_pool</span>
    <span class="k">end</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_pool</span>
      <span class="vi">@pool</span> <span class="o">=</span> <span class="no">ConnectionPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">size: </span><span class="mi">10</span><span class="p">)</span> <span class="k">do</span>
        <span class="no">Dalli</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With this, we can now access the shared connection pool across threads by calling <code class="highlighter-rouge">ConnectionManager.connection_pool</code>. To use one of the connections in the pool, we use <code class="highlighter-rouge">with</code> which will yield a connection.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ConnectionManager</span><span class="p">.</span><span class="nf">connection_pool</span><span class="p">.</span><span class="nf">with</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
  <span class="c1"># do work with the connection</span>
  <span class="n">conn</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>However, there is a slight problem. Multiple threads could access <code class="highlighter-rouge">connection_pool</code> at the same time, see that <code class="highlighter-rouge">@pool</code> hasn’t been initialized, and then each one of those threads would create another connection pool. This would cause us to create extra pools (and extra connections) which we don’t want. We only want the first thread that accesses <code class="highlighter-rouge">connection_pool</code> to initialize <code class="highlighter-rouge">@pool</code> and not the consequent ones.</p>

<p>To demonstrate the race condition, we will slightly modify the class above to show how that’s possible.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ConnectionManager</span>
  <span class="vi">@my_var</span> <span class="o">=</span> <span class="kp">nil</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">connection_pool</span>
      <span class="vi">@my_var</span> <span class="o">||</span> <span class="n">create_pool</span>
    <span class="k">end</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_pool</span>
      <span class="k">return</span> <span class="vi">@my_var</span> <span class="k">if</span> <span class="vi">@my_var</span>
      <span class="c1"># if this was thread safe, @my_var would only be updated once</span>
      <span class="nb">puts</span> <span class="s2">"updating my_var"</span>
      <span class="vi">@my_var</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
    <span class="nb">puts</span> <span class="s2">"[ThreadId=</span><span class="si">#{</span><span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">object_id</span><span class="si">}</span><span class="s2">] my_values=</span><span class="si">#{</span><span class="no">ConnectionManager</span><span class="p">.</span><span class="nf">connection_pool</span><span class="si">}</span><span class="s2">"</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">threads</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Output</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">updating</span> <span class="n">my_var</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347336477020</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="n">updating</span> <span class="n">my_var</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347336475740</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315666620</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315666480</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315666340</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315666200</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315666060</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347336475320</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="n">updating</span> <span class="n">my_var</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347336476360</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="n">updating</span> <span class="n">my_var</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70347315665900</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
</code></pre></div></div>

<p>As you can see, <code class="highlighter-rouge">create_pool</code> ends up being accessed multiple times, even when we have <code class="highlighter-rouge">return @my_var if @my_var</code> to check for initialization. There is a race condition between threads that ends up updating <code class="highlighter-rouge">@my_var</code> multiple times. We only want <code class="highlighter-rouge">@my_var</code> to be updated once no matter how many times <code class="highlighter-rouge">create_pool</code> is called.</p>

<p>We can use a <code class="highlighter-rouge">Mutex</code> to solve this.</p>

<h3 id="mutex">Mutex</h3>

<p>In the ruby documentation, the <code class="highlighter-rouge">Mutex</code> class has the following description</p>

<blockquote>
  <p>Mutex implements a simple semaphore that can be used to coordinate access to shared data from multiple concurrent threads.¹</p>
</blockquote>

<p>We can use a mutex to avoid creating multiple pools when threads initially access <code class="highlighter-rouge">ConnectionManager.connection_pool</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ConnectionManager</span>
  <span class="vi">@pool</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">connection_pool</span>
      <span class="vi">@pool</span> <span class="o">||</span> <span class="n">create_pool</span>
    <span class="k">end</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_pool</span>
      <span class="c1"># allows only one thread to access the mutex at a time which</span>
      <span class="c1"># avoids creating multiple pools</span>
      <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="k">return</span> <span class="vi">@pool</span> <span class="k">if</span> <span class="vi">@pool</span> <span class="c1"># in case threads after the first enter the mutex</span>
        <span class="vi">@pool</span> <span class="o">=</span> <span class="no">ConnectionPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">size: </span><span class="mi">10</span><span class="p">)</span> <span class="k">do</span>
          <span class="no">Dalli</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We’ve introduced a mutex in <code class="highlighter-rouge">create_pool</code> to only allow one thread to create the pool at a time. Additionally, if threads are waiting for the mutex to be free while the pool is initially being created, <code class="highlighter-rouge">return @pool if @pool</code> will stop those threads from creating a new pool when they get a chance to access the mutex.</p>

<p>At this point, we should be able to use <code class="highlighter-rouge">connection_pool</code> safely across our threads.</p>

<h3 id="in-action">In Action</h3>

<p>So we can see this in action, we will again slightly modify the above class so we can run it in many threads and see what the output is.</p>

<h3 id="with-amutex">With a Mutex</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ConnectionManager</span>
  <span class="vi">@my_var</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">connection_pool</span>
      <span class="vi">@my_var</span> <span class="o">||</span> <span class="n">create_pool</span>
    <span class="k">end</span>

     <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">create_pool</span>
      <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="k">return</span> <span class="vi">@my_var</span> <span class="k">if</span> <span class="vi">@my_var</span>
        <span class="nb">puts</span> <span class="s2">"updating my_var"</span>
        <span class="vi">@my_var</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
    <span class="nb">puts</span> <span class="s2">"[ThreadId=</span><span class="si">#{</span><span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">object_id</span><span class="si">}</span><span class="s2">] my_values=</span><span class="si">#{</span><span class="no">ConnectionManager</span><span class="p">.</span><span class="nf">connection_pool</span><span class="si">}</span><span class="s2">"</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">threads</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Output</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">updating</span> <span class="n">my_var</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279845930440</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850352420</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850352280</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850352140</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850352000</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850351840</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850351700</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279850351540</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279845930020</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
<span class="p">[</span><span class="no">ThreadId</span><span class="o">=</span><span class="mi">70279845929580</span><span class="p">]</span> <span class="n">my_values</span><span class="o">=</span><span class="mi">1</span>
</code></pre></div></div>

<p>Now, <code class="highlighter-rouge">@my_var</code> is only initialized once by the first thread and returned in consequent calls and threads.</p>

<p>There you have it! How to a create thread safe connection pool using class instance variables, a Mutex, and the <a href="https://github.com/mperham/connection_pool">connection_pool</a> gem.</p>

<h3 id="references">References</h3>

<ol>
  <li><a href="https://ruby-doc.org/core-2.6/Mutex.html">https://ruby-doc.org/core-2.6/Mutex.html</a></li>
</ol>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>
    </div>

  </body>
</html>
